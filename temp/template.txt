
SCUEC ACM
数论

素数打表判断（判断1~n的素数）

const int maxn = 100000;
bool flag[maxn+9];  //0代表是素数 	
memset(flag,0,sizeof(flag));
flag[1] = 1;
for(int  i = 2; i <= maxn/i; i++ )  //防止i*i溢出  
if (!flag[i]) 	//如果i是素数，就在maxn范围内构造合数i*j 
	for(int  j = i; i * j <= maxn; j++ ) flag[i*j] = 1; 	// i*j是合																	数，筛选掉
//直接访问flag[i] 如果是0就是素数 1合数





素数筛选（找出1~n的素数）

const int MAXN=100000; int prime[MAXN+1];  //prime[0] 代表个数 prime[1~prime[0]]依次是从小到大的素数
 void getPrime()
{
    memset(prime,0, sizeof(prime));
    for(int i=2;i<=MAXN;i++)
    {
        if(!prime[i])prime[++prime[0]]=i;
        for(int j=1; j<=prime[0] && prime[j]<=MAXN/i;j++)
        {
            prime[prime[j]*i]=1;
            if(i%prime[j]==0) break;
        }
    }
}





分解质因数

int factor[109];
int time[109];
int Prime_Factors(ULL x)  //返回因子个数 [1~n] 
{
     int fatCnt=0;
     ULL temp=x;
     for( int i = 2; i * i <= temp; i++ )
     {
     	if ( temp % i == 0 )
		 {
		 	fatCnt++;
		 	factor[fatCnt] = i;
		 	while( temp % i == 0 )
		 	{
		 		time[fatCnt]++;
		 		temp /= i;
		 	}
		 }  
     }
     if(temp!=1)
     {
         factor[++fatCnt] = temp;
         time[fatCnt] = 1;
     }
     return fatCnt;
}
分解因数
LL factor[1009];
int getfactor( LL x )
{
	int num = 0;
	for( int i = 2; i * i <= x; i++ )
		if ( x % i == 0 )
		{
			factor[++num] = i;
			if ( i * i != x ) factor[++num] = x / i;
		}
	//sort(factor+1,factor+1+num);
	return num;
}

5、约瑟夫环问题
m个人，报到k的出圈，求剩余的人
ans = 0; //最后剩余人的当前编号为0
for(int i =2;i<=m;i++) //倒推计算
ans=(ans+k) % i  //上一局的编号为ans+k
prnitf(ans+1);

6、高斯消元

普通版
const int MAXN=50;
int a[MAXN][MAXN];//增广矩阵
int x[MAXN];//解集
bool free_x[MAXN];//标记是否是不确定的变元
inline int gcd(int a,int b) {
    int t;
    while(b!=0) {
        t=b;
        b=a%b;
        a=t;
    }
    return a;
}
inline int lcm(int a,int b) {
    return a/gcd(a,b)*b;//先除后乘防溢出
}
 
// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，
//-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)
//有equ个方程，var个变元。增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var.
int Gauss(int equ,int var) {
    int i,j,k;
    int max_r;// 当前这列绝对值最大的行.
    int col;//当前处理的列
    int ta,tb;
    int LCM;
    int temp;
    int free_x_num;
    int free_index;
    for(int i=0; i<=var; i++) {
        x[i]=0;
        free_x[i]=true;
    }
    //转换为阶梯阵.
    col=0; // 当前处理的列
    for(k = 0; k <equ && col <var; k++,col++) {
        // 枚举当前处理的行.
// 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        max_r=k;
        for(i=k+1; i<equ; i++) {
            if(abs(a[i][col])>abs(a[max_r][col])) max_r=i;
        }
        if(max_r!=k) {
            // 与第k行交换.
            for(j=k; j<var+1; j++) swap(a[k][j],a[max_r][j]);
        }
        if(a[k][col]==0) {
            // 说明该col列第k行以下全是0了，则处理当前行的下一列.
            k--;
            continue;
        }
        for(i=k+1; i<equ; i++) {
            // 枚举要删去的行.
            if(a[i][col]!=0) {
                LCM = lcm(abs(a[i][col]),abs(a[k][col]));
                ta = LCM/abs(a[i][col]);
                tb = LCM/abs(a[k][col]);
                if(a[i][col]*a[k][col]<0)tb=-tb;//异号的情况是相加
                for(j=col; j<var+1; j++) {
                    a[i][j] = a[i][j]*ta-a[k][j]*tb;
                }
            }
        }
    }
 
    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).
    for (i = k; i<equ; i++) {
        if (a[i][col] != 0) return -1;
    }
    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
    // 且出现的行数即为自由变元的个数.
    // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.
    if (k <var) {
        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.
        for (i = k - 1; i>= 0; i--) {
            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.
            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.
            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.
            for (j = 0; j <var; j++) {
                if (a[i][j] != 0 &&free_x[j]) free_x_num++, free_index = j;
            }
            if (free_x_num> 1) continue; // 无法求解出确定的变元.
            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.
            temp = a[i][var];
            for (j = 0; j <var; j++) {
                if (a[i][j] != 0 && j != free_index) temp -= a[i][j] * x[j];
            }
            x[free_index] = temp / a[i][free_index]; // 求出该变元.
            free_x[free_index] = 0; // 该变元是确定的.
        }
        return var - k; // 自由变元有var - k个.
    }
    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.
    // 计算出Xn-1, Xn-2 ... X0.
    for (i = var - 1; i>= 0; i--) {
        temp = a[i][var];
        for (j = i + 1; j <var; j++) {
            if (a[i][j] != 0) temp -= a[i][j] * x[j];
        }
        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.
        x[i] = temp / a[i][i];
    }
    return 0;
}

对2取模的01方程组
const int MAXN = 40;
//有equ个方程，var个变元。增广矩阵行数为equ,列数为var+1,分别为0到var
int equ,var;
int a[MAXN][MAXN]; //增广矩阵
int x[MAXN]; //解集
int free_x[MAXN];//用来存储自由变元（多解枚举自由变元可以使用）
int free_num;//自由变元的个数
// 每次清空增广矩阵
//y方向是x1,x2,x3...xn
//x方向是对每一个x值列一个方程

//返回值为-1表示无解，为0是唯一解，否则返回自由变元个数
int Gauss() {
    int max_r,col,k;
    free_num = 0;
    for(k = 0, col = 0 ; k <equ&& col <var ; k++, col++) {
        max_r = k;
        for(int i = k+1; i<equ; i++) {
            if(abs(a[i][col]) > abs(a[max_r][col]))
                max_r = i;
        }
        if(a[max_r][col] == 0) {
            k--;
            free_x[free_num++] = col;//这个是自由变元
            continue;
        }
        if(max_r != k) {
            for(int j = col; j < var+1; j++)
                swap(a[k][j],a[max_r][j]);
        }
        for(int i = k+1; i<equ; i++) {
            if(a[i][col] != 0) {
                for(int j = col; j < var+1; j++)
                    a[i][j] ^= a[k][j];
            }
        }
    }
    for(int i = k; i<equ; i++)
        if(a[i][col] != 0)
            return -1;//无解
    if(k <var) return var-k;//自由变元个数
    //唯一解，回代
    for(int i = var-1; i>= 0; i--) {
        x[i] = a[i][var];
        for(int j = i+1; j <var; j++)
            x[i] ^= (a[i][j] && x[j]);
    }
    return 0;
} 
7、判断大数是否为素数
/* *************************************************
* Miller_Rabin 算法进行素数测试
* 速度快，可以判断一个 < 2^63 的数是不是素数
* #include <ctime> <cstdlib> 
**************************************************/
const int S = 8; //随机算法判定次数，一般8~10就够了
// 计算ret = (a*b)%c a,b,c < 2^63
long long mult_mod(long long a, long long b, long long c)
{
     a %= c;
     b %= c;
     long long ret = 0;
     long long tmp = a;
     while(b)
    {
        if(b & 1)
         {
             ret += tmp;
             if(ret > c)ret -= c; //直接取模慢很多
         }
         tmp <<= 1;
         if(tmp > c)tmp -= c;
         b >>= 1;
     }
     return ret;
}


// 计算 ret = (a^n)%mod
long long pow_mod(long long a, long long n, long long mod)
{
 long long ret = 1;
 long long temp = a%mod;
 while(n)
 {
     if(n & 1)ret = mult_mod(ret,temp,mod);
     temp = mult_mod(temp,temp,mod);
     n >>= 1;
 }
 return ret;
}
// 通过 a^(n-1)=1(mod n) 来判断n是不是素数
// n-1 = x*2^t 中间使用二次判断
// 是合数返回true, 不一定是合数返回false
bool check(long long a, long long n, long long x, long long t)
{
 long long ret = pow_mod(a,x,n);
 long long last = ret;
 for(int i = 1;i <= t;i++)
 {
     ret = mult_mod(ret,ret,n);
     if(ret == 1 && last != 1 && last != n-1) return true; //合数
     last = ret;
 }
 if(ret != 1) return true;
 else return false;
}
//**************************************************
// Miller_Rabin算法
// 是素数返回true,(可能是伪素数)
// 不是素数返回false
//**************************************************
bool Miller_Rabin(long long n)   //调用此函数来判断
{
 if( n < 2) return false;
 if( n == 2) return true;
 if( (n&1) == 0) return false; //偶数
 long long x = n - 1;
 long long t = 0;
 while( (x&1)==0 ){x >>= 1; t++;}
 srand(time(NULL));  /* *************** */
 for(int i = 0;i < S;i++)
 {
     long long a = rand()%(n-1) + 1;
     if( check(a,n,x,t) )
     return false;
 }
 return true;
}


分解大数  调用 findfac(n,107); 需要 Miller_Rabin
long long factor[100]; //质因素分解结果（刚返回时时无序的）
int tol; //质因素的个数，编号0~tol-1
long long gcd(long long a, long long b)
{
     long long t;
     while(b)
     {
         t = a;
         a = b;
         b = t%b;
     }
     if(a >= 0) return a;
     else return -a;
}
//找出一个因子
long long pollard_rho(long long x, long long c)
{
     long long i = 1, k = 2;
     srand(time(NULL));
     long long x0 = rand()%(x-1) + 1;
     long long y = x0;
     while(1)
     {
         i ++;
         x0 = (mult_mod(x0,x0,x) + c)%x;
         long long d = gcd(y - x0,x);
         if( d != 1 && d != x) return d;
         if(y == x0) return x;
         if(i == k){y = x0; k += k;}
     }
}
//对 n进行素因子分解，存入factor. k设置为107左右即可
void findfac(long long n, int k)
{
     if(n == 1) return;
     if(Miller_Rabin(n))
     {
     factor[tol++] = n;
     return;
     }
     long long p = n;
     int c = k;
     while( p >= n)
        p = pollard_rho(p,c--); //值变化，防止死循环k
     findfac(p,k);
     findfac(n/p,k);
}

8、扩展欧几里得算法
ax+by = gcd(a,b) = gcd(b,a%b) = b x1 + (a-a/b*b)y1 =a*y1+b*x1-a/b*b*y1
a*x=a*y1
b*y=b*x1 - a/b*b*y1
x= y1
y = x1 - (a/b)*y1
int exgcd(int a,int b,int &x,int &y)  //返回最大公约数，x，y存的是一组解
{
    if(b==0)
    {
        x=1;
        y=0;
        return a;
    }
    int r=exgcd(b,a%b,x,y);
    int t=x;
    x=y;
    y=t-a/b*y;
    return r;
}  
 p = p0 + b/Gcd(a, b) * t
 q = q0 - a/Gcd(a, b) * t (其中t为任意整数)

（1）求解不定方程
对于不定整数方程ax+by=c，若 c mod Gcd(a, b)=0,则该方程存在整数解，否则不存在整数解。
bool linear_equation(int a,int b,int c,int &x,int &y)
{
    int d=exgcd(a,b,x,y);
    if(c%d)
        return false;
    int k=c/d;
    x*=k; y*=k;    //求得的只是其中一组解
    return true;
}

（2）求解模线性方程的方法
ax≡b(mod n) => ax + ny = b 对于未知数 x 有解，当且仅当 gcd(a,n) | b。且方程有解时，方程有 gcd(a,n) 个解。 
d = gcd(a,n) 
我们设解之间的间隔为dx.dx = n/d , lcm(n/d) = a*n/d
    求解方程 ax≡b (mod n) 相当于求解方程 ax+ ny= b, (x, y为整数)
bool modular_linear_equation(LL a,LL b,LL n)  //ax≡b(mod n)
{
    LL x,y,x0;
    LL d=exgcd(a,n,x,y);
    if(b%d)
        return false;
    x0=x*(b/d);   //特解
    LL xx = n/d;
    ans = (x0%xx+xx)%xx;
return true;
}
（3）用欧几里德算法求模的逆元：
      同余方程ax≡b (mod n)，如果 gcd(a,n)== 1，则方程只有唯一解。
      在这种情况下，如果 b== 1，同余方程就是 ax=1 (mod n ),gcd(a,n)= 1。
      这时称求出的 x 为 a 的对模 n 乘法的逆元。
      对于同余方程 ax= 1(mod n )， gcd(a,n)= 1 的求解就是求解方程
      ax+ ny= 1，x, y 为整数。这个可用扩展欧几里德算法求出，原同余方程的唯一解就是用扩展欧几里德算法得出的 x 。


9、Lacus 大数取模 C(n,m) % p  p<=10^5
Lucas(n,m,p)=c(n%p,m%p)*Lucas(n/p,m/p,p) 
LL fact[100009];
//**********使用************
getfact(p);  //先处理出来1~p的阶乘%p;
Lucas(n,m,p);
//**********使用************

LL pow_mod(LL a,LL b,LL m)
{
    LL ans = 1;
    a%=m;
    LL temp = a;
    while( b )
    {
        if ( b & 1 ) ans = ( temp * ans )% m;
        temp = ( temp * temp )% m;
        b>>=1;
    }
    return ans;
}

void getfact(int p)
{
    fact[0] = 1;
    rep(i,1,p) fact[i] = (i*fact[i-1])%p;
}

LL Lucas( LL n ,LL m ,LL p)     //  C(n,m) % p
{
    LL ans = 1;
    while( n && m )
    {
        LL a = n % p;
        LL b = m % p;
        if ( a < b ) return 0;
        if ( b > a-b ) b = a - b;
        ans = ( ans * (fact[a]* pow_mod( fact[b]*fact[a-b] , p-2 , p ))%p ) % p;
        n /= p;
        m /= p;
    }
    return ans;
}

10、欧拉函数
①单个欧拉函数的计算
Phi(n) = (pi-1) * pi^(a-1)

LL cal( LL x )
{
    LL ans = 1;
    for( int i = 2; i*i <= x; i++ )
    {
        if ( x % i == 0)
        {
            ans*=i-1;
            x /= i;
            while( x % i == 0 )
            {
                ans *= i;
                x /= i;
            }
        }
    }
    if ( x > 1 ) ans*=(x-1);
    return ans;
}
②线性筛欧拉函数 ( NlogN )
找到n的最小质因数  phi( p ^a ) = (p-1)* p^( a - 1 )
如果n只能整除k，phi(n) = phi( n/k )*(k-1)
否则 phi(n) = phi(n/k)*k  
/*
Phi[]
Mindiv[]  能整除的最小的质因数
*/
void getphi(int n)
{
    rep(i,1,n) mindiv[i] = i;
    for(int i = 2; i*i <= n; i++)
        if ( mindiv[i] == i )
        {
            for(int j = i*i; j <= n; j+=i) mindiv[j] = i;
        }
    phi[1] = 1;
    rep(i,2,n)
    {
        phi[i] = phi[i/mindiv[i]];
        if ( ( i / mindiv[i] ) % mindiv[i] == 0 ) phi[i] *= mindiv[i];
        else phi[i] *= ( mindiv[i] - 1 );
    }
}


11、中国剩余定理
X 同余 a[i] ( mod m[i] )  ，有n个式子(ai,mi)，求X
LL CRT( LL a[] , LL m[] , int n )
{
    LL M = 1;
    rep(i,1,n) M*=m[i];
    LL ans = 0;
    rep(i,1,n)
    {
        LL x,y;
        LL tm = M / m[i];
        extend_gcd(tm,m[i],x,y);
        ans = ( ans + multi(multi(x,tm,M),a[i],M) ) % M;
    }
    return ( ans + M )% M;
}
求逆元
①如果( mod P )P为素数,a的逆元为a^(P-2)  费马小定理
②ans = a/b mod(m) = a mod(m*b)/b 





数据结构
STL
①struct重载<
struct node
{
    int a,b;
    node(int x = 0,int y = 0):a(x),b(y){}
    bool operator<(const node& rhs) const
    {
        if ( a == rhs.a ) return b > rhs.b; //b越小优先级越高
        else return a < rhs.a; //a越大优先级越高
    }
};
②Proirity_queue(默认大根堆)
priority_queue< int , vector<int> , greater<int> > q  小根堆

③set
#define ALL(x) x.begin(),x.end()
#define INS(x) inserter(x,x.begin())
Set_union( ALL(x1) , ALL(x2) , INS(x) ); vector x为 x1和x2的并集
Set_intersection( ALL(x1) , ALL(x2) , INS(x) ); vector x为 x1和x2的交集

④depue
c.front()返回c容器的第一个元素
c.push_front(num)在开头位置插入元素
c.pop_front()删除开头位置的元素

c.back()返回c容器的最后一个元素
c.push_back(num)在末尾位置插入元素
c.pop_back()删除末尾位置的元素

⑤vector
erase(vector.begin())删除头元素
Pop/push_back(); 删除/插入尾元素


2、树状数组
（1）一维
更新：从当前到n
查询：从当前到0
（2）一维拓展
int bit0[]; //原数组前缀和 原数操作在这上面
int bit1[]; //增加的前缀和
//**********使用说明**********
①在[L,R]区间上整体加x
update(bit0,L,-x*(L-1));
update(bit1,L,x);
update(bit0,R+1,x*R);
update(bit1,R+1,-x);

②求[L,R]的和
res += query( bit0 , R ) + query( bit1 ,R ) * R;  求[1,R]
res -= query( bit0 , L-1 ) + query( bit1 , L-1 ) * (L-1);

二维树状数组

void update(int x,int y,int k)   [1]..[x]  ,  [1]..[y]  每个元素加k
{
    while (x<=N)
    {
        int ty=y;
        while (ty<=N)
        {
            sum[x][ty]+=k;
            ty+=lowbit(ty);
        }
        x+=lowbit(x);
    }
}

int query(int x1,int y1)
{
    int s=0;
    while (x1>0)
    {
        int ty=y1;
        while (ty>0)
        {
            s+=sum[x1][ty];
            ty-=lowbit(ty);
        }
        x1-=lowbit(x1);
    }
    return s;
}
Trie树
静态建树  把握maxnode的大小 
struct trie  
{
	int next[maxnode][sz]; 
	bool end[maxnode]; //标记是否为一个结尾 
	int size; // 当前大小
	trie()
	{
		size = 0;
		memset(next,0,sizeof(next));
		memset(end,false,sizeof(end));
	}
	
	void insert(char s[])  //插入一个字符串
	{
		int len = strlen(s);
		int now = 0;
		for( int i = 0; i < len; i++ )
		{
			int index = s[i] - 'a'; //当前字符对应的下一个节点的下标
			if ( !next[now][index] ) 
			{
				next[now][index] = ++size;  //新开一个节点
			}
			now = next[now][index]; 
		}
		end[now] = true;	//结尾标记为字符串结尾
	}
	
	bool find(char s[])  //查找是否含有这个字符串
    {
        int now = 0;
        int len = strlen(s);
        for(int i = 0; i < len; i++)
        {
            int index = s[i] - 'a';
            if ( !next[now][index] ) return false; // 如果这个节点没有拓展过，也就不存在这个字符串
            now = next[now][index];
        }
        return end[now]; //返回这个节点有没有结束标记
    }
	
};

（2）动态建树	速度相对慢一些，节约内存
struct trie
{
    trie* next[size];
    bool flag;  //当前节点是否为结尾
};

void init(trie* x) //初始化一个节点
{
    x->flag = false;
    for(int i = 0; i < size; i++) x->next[i] = NULL;
}

void insert(trie* x,char s[])  //插入字符串
{
    int len = strlen(s);
    for(int i = 0; i < len; i++)
    {
        int index = s[i] - 'a';
        if ( x->next[index] == NULL )
        {
            x->next[index] = new trie;  //申请新空间
            init(x->next[index]);
        }
        x = x->next[index];
    }
    x->flag = true;
}

bool query(trie* x,char s[])
{
    int len = strlen(s);
    for(int i = 0; i < len; i++)
    {
        int index = s[i] - 'a';
        if ( x->next[index] == NULL ) return false;
        x = x->next[index];
    }
    return x->flag;
}

trie *root = new trie;
init(root);
insert(root,str);

4、线段树
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
#define mid int m=(l+r)>>1

void pushdown(int rt,int k)
{
    if (dealy[rt])
    {
        dealy[rt<<1]+=dealy[rt];  //非替换时不可写成连等
        dealy[rt<<1|1]+=dealy[rt]; 
        sum[rt<<1]+=dealy[rt]*(k-(k>>1));
        sum[rt<<1|1]+=dealy[rt]*(k>>1);
        dealy[rt]=0;
    }
}

void build(int l,int r,int rt)
{
    dealy[rt]=0;
    if (l==r)
    {
        scanf("%d",&sum[rt]);
        return;
    }
    int m=(l+r)>>1;
    build(lson);
    build(rson);
    pushup(rt);
}


void add(int L,int R,int c,int l,int r,int rt)
{
    if (L<=l && r<=R)
    {
        dealy[rt]+=c;
        sum[rt]+=c*(r-l+1);
        return;
    }
    pushdown(rt,r-l+1);
    int m=(l+r)>>1;
    if (L<=m) add(L,R,c,lson);
    if (m<R) add(L,R,c,rson);
    pushup(rt);
}


int query(int L,int R,int l,int r,int rt)
{

    if(L<=l && r<=R) return sum[rt];
    pushdown(rt,r-l+1);
    int m=(l+r)>>1;
    int ans=0;
    if (L<=m) ans+=query(L,R,lson);
    if (m<R) ans+=query(L,R,rson);
    return ans;
}
动态规划


三、RMQ
1、二分答案查找
结束后 l = r
（1）找到满足条件的值的最大值  满足的值在左侧,向右找
while (l<r)
{
    mid=(l+r)>>1;
    if ( check(mid+1) ) 
	l=mid+1;
    else
	r=mid;
}

（2）找到满足条件的值中的最小值  满足的值在右侧
while (l<r)
{
    mid=(l+r)>>1;
    if ( check(mid) )
	r=mid;
    else
	l=mid+1;
}

ST算法	O(1)查询 O(nlogn)预处理
不能高效更新
f[i][j]:以[i]开头连续的2^j区间内维护的值。

初始化：
2^k <= n; (k为满足条件的最大值)
for( int i = 1; i <= n; i++ ) f[i][0] = a[i];
for( int j = 1; j <= k; j++ )
{
	for( int i = 1; i <= n + 1 - (1<<j); i++ )  //枚举开头i
		f[i][j] = max( f[i][j-1] , f[ i + ( 1<< (j-1) ) ][j-1] ); 
}

查询[x,y]范围内的值：
2^k <= y - x + 1  (k为满足条件的最大值)
return max( f[x][k] , f[ y + 1 - (1<<k) ][k] )

3、三分法     double Left, Right;     double mid, midmid;     double mid_value, midmid_value;     Left = MIN; Right = MAX;     while (Left + EPS < Right)     {         mid = (Left + Right) / 2;         midmid = (mid + Right) / 2;         mid_area = Calc(mid);         midmid_area = Calc(midmid);         // 假设求解最大极值.         if (mid_area >= midmid_area) Right = midmid;         else Left = mid;     } 	

动态规划
数位DP
(1)直接递推
Dp[i][j]  以j开头的i位数中所含答案的数量。
可以通过递推先预处理好，然后再分情况统计。
一般可以分两种情况统计：
1、最高位不达到上限，每一位可以取任意值
Ans+=dp[len][i]   i ∈ [ 0 , digit[len]-1 ]

Tips：如果前导零会对答案造成影响，应该将这一类分为长度为len和长度小于len两种统计，其实这里最好分为两类统计不容易出错，只是这样算0不会被考虑进去。
1)i = 1 to len-1  //枚举长度
  j = 1 to 9  ans+=dp[i][j]
2)i = 1 to digit[len]-1 ans+=dp[len][i] 

2、最高位达到上限
从最高位开始，每次固定一个数位，然后统计以前面已经固定的数位开头的范围内所含答案的个数。
For( int i = len-1; i >= 1; i-- )
For( int j = 0; j <digit[i]; j++ ) ans+=dp[i][j];
比如489，先固定4，统计400~47范围内；再固定8，统计480~488。
但是这样算不到上限值，通常可以用单独判断或者传参数时传入x+1来解决。

dfs+记忆化
/*
pos表示当前dfs到第几层，dfs到第0层就结束
flag表示是否选取数位到范围上界，如果达到上界那么就有一些数位不能随意选取
state表示当前状态，不同的问题涉及到的状态不一样 
*/ 

int dfs(int pos , int state , bool flag) 
{
	if ( pos == 0 ) return check(state);
	if ( !falg && dp[pos][state] != -1 ) return dp[pos][state];
	int ed = flag?bit[pos]:9;
	int ans = 0;
	for( int i = 0; i <= ed; i++ )//枚举当前位可以取的数 
	{
		ans+=dfs( pos - 1 , nextstate(state) , flag && i == ed );//统计答案 
	}
	if ( !flag ) dp[pos][state] = ans; //记录答案，下次碰到这种情况直接输出即可 
	return ans;
}
例：
是否含一个数，例如”13”。
在dfs中记录上一位是什么数，在当前位分类讨论。
Dp[i][id] 分为3类
Dfs(int pos , int id , ......)
Dp[i][0] 当前从最高位dfs到第i位，且之前不含”13”，也不是以1结尾的
Dp[i][1] 之前不含”13”，是以1结尾的
Dp[i][2] 包含”13”
这样我们dfs的时候根据之前的id进行判断。
如果id=0 且当前位枚举的数为1 那么就是以1结尾了，dfs(pos-1 , 1...)
如果id=1 且当前位枚举的数不为1、3 那么就dfs(pos-1 ,0...)
如果id=1 且当前位枚举的数为3 那么就是含”13”，dfs(pos-1 , 2...)
最后判断id==2即可。
同理判断不含”13”更简单，只需要分为以1结尾或者不以1结尾，如果是以1结尾那么下一位就不可以为3，dfs到最后一层直接返回1即可，因为不合法的情况中途就排除掉了。

状态压缩Dp


骨牌平铺问题

1*2的骨牌 
横着放算11

 0
竖着放算 1

先初始化第一行，满足相邻的1的个数为偶数个才可以，第一行只能横着放。

然后枚举上一行x2 和 当前行的状态x1
当前行x1放上去x2一定要放满了，所以x1|x2 == uplim
其次 x1 & x2的状态应为第一行可行的状态 因为x1 & x2的结果一定是横着放的状态



图论
（1）Dijkstra+堆优化
typedef pair<int,int>Pair;
int dijkstra(int start,int end)
{
  for (int i=1;i<=n;i++) dis[i]=1000000000;
  memset(flag,0,sizeof(flag));
  dis[start]=0;
  priority_queue< Pair,vector<Pair>,greater<Pair> >q;
  q.push(make_pair(dis[start],start));
  
  while (!q.empty())
  {
    Pair top=q.top();
    q.pop();
    int now=top.second;
    if (flag[now]) continue;
    flag[now]=true;
    for (int j=1;j<=n;j++)
      if ((!flag[j])&&(a[now][j]+dis[now]<dis[j]))
      {
        dis[j]=dis[now]+a[now][j];
        q.push(make_pair(dis[j],j));
      }
  }
  return dis[end];
}

快速幂 a^b % m
LL pow_mod(LL a,LL b,LL m)
{
    LL ans = 1;
    a%=m;
    LL temp = a;
    while( b )
    {
        if ( b & 1 ) ans = ( temp * ans )% m;
        temp = ( temp * temp )% m;
        b>>=1;
    }
    return ans;
}

大数相乘
LL multi(LL a,LL b,LL p)   //大数 （a×b）%p
{
    int sign = 1;
    if ( b < 0 )
    {
        b = -b;
        sign = -1;
    }
    LL ret=0;
    while(b)
    {
        if(b&1)
            ret=(ret+a)%p;
            a=(a+a)%p;  //a*2^0  a*2^1  a*2^2  a*2^4
            b>>=1;
    }
    return ret*sign;
}



矩阵乘法
	0 1 * f(n-1) =  f(n)	    
	1 1   f(n)	f(n+1)  //f(n-1)+f(n)

	f(n) = [0 1] 的(n-1)次方后 f[1,2]+f[2,2]  
	       [1 1]           
FIB前n项和:
		f(1)+f(2)+...+f(n)=f(n+2)-1

矩阵快速幂
matrix multi(matrix a,matrix b)
{

    matrix temp;
    memset(temp.num,0,sizeof(temp.num));
    time++; // 记录调用次数
    rap(i,j,k,2)
        temp.num[i][j]=(temp.num[i][j]+a.num[i][k]*b.num[k][j])mod;
    return temp;
}

//res 存结果  t存阶段矩阵 
LL fib(int n)  // n-1 个  1 1  矩阵相乘 
{              //	  1 0
    int tn;
    matrix res,t;
    if ( n==1 || n==2 ) return 1;
    tn=n-1;

    res.num[1][1]=res.num[2][2]=1;
    res.num[1][2]=res.num[2][1]=0;
    t.num[1][1]=t.num[1][2]=t.num[2][1]=1;
    t.num[2][2]=0;
    while (tn)
    {
        if (tn & 1)
            res=multi(res,t);
        t=multi(t,t);
        tn=tn>>1;
    }
    return res.num[1][1];
}




状态压缩Dp技巧
for ( int i = 0; i < (1 << n); i ++ )  //对于一个状态i
            for ( int j = (i - 1) & i; j; j = (j - 1) & i ) //枚举它的所有子状态

其他公式技巧
∑n^2 = n(n+1)(2n+1)/6
∑n^3 = n²(n+1)²/4
∑n^4 = n(n+1)(2n+1)(3n^2+3n-1)/30
log2 n =logn/log2
const lldouble PI = acos(-1.0); // Pi
memset 0x3f = 10 6000 0000    10 6110 9567
#pragma comment(linker, "/STACK:1024000000,1024000000")
srand(time(0)); #include<time.h> rand()%100
std::ios::sync_with_stdio(false);
while(next_permutation(a+1,a+1+n))
next/prev_permutation
reverse(a,a+len) 翻转a[0]至a[len-1]

freopen("input.txt", "r", stdin); 
freopen("output.txt", "w", stdout);
重新定位到控制台
freopen("CON", "w", stdout); 
freopen("CON","r",stdin);   //加这一句,"CON"代表控制台
fclose(stdin);
fclose(stdout);